## Video Podcast

[FP 16 - Lazy Evaluation](https://www.youtube.com/watch?v=84bwnE2KZiA)

## Reading

Please read:

- Chapter 15 of *Programming in Haskell*

## Learning Goals

- To be able to precisely explain the two main evaluation strategies: call-by-value and call-by-name, and the notion of a redex
    
    **Call-by-value** evaluates the arguments of a function *before* the function is applied. Only the resulting values are passed to the function.
    **Call-by-name** does *not* evaluate arguments before passing them; instead, the function receives the unevaluated expressions themselves, which are evaluated only if needed.
    A **redex** (reducible expression) is an expression that can be simplified by applying a computation rule, such as a function application.

- To be able to precisely explain the notion of lazy evaluation
    
    **Lazy evaluation** is a strategy where expressions are not evaluated until their values are actually required. Haskell uses lazy evaluation by default. This avoids unnecessary computation and allows programs to work with expressions that might not terminate under strict evaluation.

- To understand how lazy evaluation allows Haskell to express infinite structures and perform finite computations on such structures

    Because of lazy evaluation, Haskell can represent infinite data structures (such as infinite lists). Only the parts that are actually needed for a computation are evaluated. This allows finite computations to successfully operate on conceptually infinite inputs.

- To understand how strict application can be used in Haskell
    
    Although Haskell is lazy by default, it provides mechanisms for **strict application**, which forces an expression to be evaluated immediately. This is useful when laziness would cause inefficiency (e.g., building large unevaluated thunks) or when a function logically requires its argument to be fully evaluated.

## Preparation Before Class

Before we meet on Tuesday, watch the podcast and read the text (in any order you prefer).
Try to solve the following two small discussion problems. We will talk about them in class.

### Discussion Problems

1. Give two different definitions (one using recursion, one not using recursion) of a function `nsonly` that takes as input a number `n` and gives the infinite list consisting of `0*n, 1*n, 2*n, 3*n, ...`.
    ```haskell
    nsIonly n = map (^ n) [0..]

    nsRonly = nonly [0..]

    nonly (x:xs) n = x^n : nonly xs n 
    ```
    and the tests
    ```haskell
    ghci> take 5 (nsRonly 5)
    [0,1,32,243,1024]
    ghci> take 5 (nsIonly 5)
    [0,1,32,243,1024]
    ```

2. Consider the following definition:

   ```haskell
   plip = fst (17, f 484000)
     where f x = f (x + 1)
   ```

   What is the value of `plip`? Explain.

   The value of `plip` is 17 because out of a tuple with 2 elements we are taking the first one with the `fst` function.
   The value computed by the function `f` will never be computated because of the lazy evaluation.


