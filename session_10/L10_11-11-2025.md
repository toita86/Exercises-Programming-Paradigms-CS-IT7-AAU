# The video podcast
You can watch the podcast on YouTube 
[AFP5](https://www.youtube.com/watch?v=FDIwb1lVi9U)
[AFP6](https://www.youtube.com/watch?v=8oVHISjS3wI)

Tuesday 11 November 2025 – Functors
Please read Sections 12.1 and 12.2 of Programming in Haskell.

# Learning goals for the session
### **1. Understanding the notion of a functor**

A **functor** is a type class in Haskell that represents types that can be mapped over. It provides the `fmap` function, which applies a function to values inside a context (like a list or `Maybe`) without changing the structure.

***

### **2. Familiar type constructs as functor instances**

Types like `Maybe` and lists are **functor instances** because you can apply a function to their contents using `fmap`. For example:

*   `fmap (+1) (Just 2)` results in `Just 3`
*   `fmap (*2) [1,2,3]` results in `[2,4,6]`

***

### **3. Understanding applicative functors**

An **applicative functor** is a more powerful abstraction than a functor. It allows you to apply functions that are themselves inside a context to values inside another context using `<*>`.

***

### **4. Understanding `pure` and `<*>` operations**

*   `pure` takes a value and puts it into a default context (e.g., `pure 3` becomes `Just 3` or `[3]`).
*   `<*>` applies a function inside a context to a value inside another context.
    Example: `Just (+1) <*> Just 2` results in `Just 3`.

***

### **5. Applying functors and applicatives in Haskell programs**

Using **functors** and **applicative functors** helps write cleaner, more modular code by abstracting over computations with context (like optional values, lists, or effects). They enable a declarative style of programming that avoids manual unpacking of values.

# How you should prepare before we meet on Tuesday
Before we meet, watch the podcast and read the text. You can do this in any order you
like. Also see if you can solve the following two small discussion problems. We will talk
about them in class.

1. An onion consists of a finite number of layers surrounding a core. In this problem,
we let the core be a value. Figure 0.1 shows an onion with six layers and core
”bingo”. Below is a declaration of an algebraic datatype Onion a parameterized by
the type a.

```Haskell
data Onion a = Core a | Layer ( Onion a )
```

Define Onion as an instance of Functor. Hint: Be inspired by how the book shows
how one can let the Tree type become an instance of Functor.

my porposed solution:
```Haskell
data Onion a = Core a | Layer (Onion a) deriving Show

instance Functor Onion where
  -- fmap :: (a -> b) -> Onion a -> Onion b 
  fmap g (Core a) = Core (g a)
  fmap g (Layer o) = Layer (fmap g o)
```

ghci examples:

```Haskell
ghci> fmap length (Core "bingo")
Core 5
ghci> fmap head (Core "bingo")
Core 'b'
ghci> fmap init (Core "bingo")
Core "bing"
ghci> fmap (!! 2) (Core "bingo")
Core 'n'
ghci> fmap length (Layer (Core "bingo"))
Layer (Core 5)
```


2. Check that the first two applicative laws at the top of page 163 hold for the Maybe
type. Hint: Use the definitions of pure and <∗> on page 160.

prove it by hand



