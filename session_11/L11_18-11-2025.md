# The video podcast
[AFP 7 - Monads I: Basic Concepts](https://www.youtube.com/watch?v=NBO6kN7JEAw)
[AFP 8 - Monads II: Maybe, List and State](https://www.youtube.com/watch?v=9injd7JE6vU)

# Tuesday 18 November 2025 – Monads
Please read
• Section 12.3 of Programming in Haskell.

## Learning goals for the session
### **1. The Maybe Monad**

The **Maybe monad** represents computations that may fail. It has two constructors:

*   `Just x` for a successful result.
*   `Nothing` for failure or absence of value.
    It allows chaining operations without explicit null checks: if any step returns `Nothing`, the entire computation short-circuits.

***

### **2. Definition of a Monad**

A **monad** is a design pattern that represents computations as a series of steps. Formally, a monad is a type constructor `M` with two operations:

*   `return :: a -> M a` (wraps a value in the monad)
*   `>>= :: M a -> (a -> M b) -> M b` (binds a value to a function producing a monadic result)
    It must satisfy **three laws**: left identity, right identity, and associativity.

***

### **3. Bind Operator (`>>=`) and Do Notation**

The **bind operator** (`>>=`) chains monadic operations:

```haskell
m >>= f
```

takes a monadic value `m` and applies function `f` to its unwrapped value.  
**Do notation** is syntactic sugar for `>>=`:

```haskell
do
  x <- m
  y <- f x
  return y
```

This makes monadic code look imperative while preserving functional semantics.

***

### **4. The List Monad**

The **List monad** represents nondeterministic computations. Binding (`>>=`) applies a function to each element of a list and concatenates the results:

```haskell
[1,2] >>= \x -> [x, x+1]  -- Result: [1,2,2,3]
```

It models computations with multiple possible outcomes, such as generating combinations.

***

### **5. The State Monad**

The **State monad** encapsulates stateful computations in a pure functional way. It represents a function:

```haskell
State s a ≡ s -> (a, s)
```

where `s` is the state and `a` is the result.  
It allows threading state through a sequence of operations without explicit passing:

```haskell
do
  x <- get
  put (x+1)
  return x
```

Useful for counters, configuration, or any mutable-like behavior in functional programming.


### Monad Chaining Diagram

![Monad Chaining]
**Explanation:**
- **Maybe Monad**: `Just x` → `Just y` → `Just z` (short-circuits on `Nothing`)
- **List Monad**: `[x₁, x₂]` → `[y₁, y₂, y₃]` → `[z₁, z₂]` (nondeterministic expansion)
- **State Monad**: `(x, s)` → `(y, s₁)` → `(z, s₂)` (threads state through computations)


## How you should prepare before we meet on Tuesday
Before we meet, watch the podcast and read the text. You can do this in any order you like. Also see if
you can solve the following two small discussion problems. We will talk about them in class.

1. Define a function
```Haskell
tuple :: Monad m => m a −> m b −> m( a , b )
```
using explicit (`>>=`) and then again, now using do-notation. What does the function do in the
case, where the monad is Maybe?

```haskell
tuple ma mb = ma >>= \a ->
              mb >>= \b -> 
              return (a,b)

tuple' ma mb = do
                a <- ma
                b <- mb
                return (a,b)
```

Using the Maybe allow us to have values such as Nothing as in put and not have crush of the program
```haskell
ghci> tuple' (Just 4) (Just 3)
Just (4,3)

ghci> tuple' (Just 4) (Nothing)
Nothing
```

2. What is the expression (that uses (`>>=`) that is equivalent to the following do block? (You will
have to look up the definition of (`>>=`))
```Haskell
do y <− z
s y
return ( f y )
```

