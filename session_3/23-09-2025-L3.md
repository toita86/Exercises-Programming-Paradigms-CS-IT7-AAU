# Video Podcast

You can watch the podcast on **YouTube** via the course page on **Moodle**(The videos on Moodle are available only if you are a AAU student).

- Hans Hüttel: [Static and dynamic typing](https://www.moodle.aau.dk/pluginfile.php/3688219/course/section/711513/Dynamictyping.pdf)
- Hans Hüttel: [The lambda calculus](https://www.moodle.aau.dk/pluginfile.php/3744008/mod_resource/content/1/The%20Untyped%20Simple%20Lambda-Calculus.pdf)
- Graham Hutton [Lambda calculus](https://www.youtube.com/watch?v=eis11j_iGMs)
- Graham Hutton, _Programming in Haskell_: Chapter 3
- Graham Hutton: [FP5 Types and Classes](https://www.youtube.com/watch?v=6w38pf__nZk)

---

## Session Details
**Date:** Tuesday 23 October 2025  
**Topic:** Types and classes  

### Texts
- *Programming in Haskell* — Chapter 3  
- The short note about the λ-calculus  
- The short note *Static and dynamic typing*  

---

## Learning Goals for the Session

>[!danger] Note 
>The learning goals for Haskell and the theoretical foundations for this session are **not related**.

### Haskell
- Explain and use the central notions of types in Haskell:  
  - basic types
	  - `Bool
	  - `Char`
	  - `String`
	  - `Int` fixed precision integers max $2^{63}-1$
	  - `Integer` arbitrary-precision integers
	  - `Float`
	  - `Double`
  - list types 
	  A list is a sequence of elements of the same type, with the elements being enclosed in square parentheses and separated by commas.
  - function types 
	  We write `T1 -> T2` for the type of all functions that map arguments of type `T1` to results of type `T2`.
  - tuple types
	  A tuple is a finite sequence of components of possibly different types, with the components being enclosed in round parentheses and separated by commas. We write `(T1,T2,...,Tn)`.
- Explain and use curried and uncurried functions, and relate these notions to higher-order functions.
	To have functions with multiple arguments instead of using a tuple, that in fact is just a type not multiple, we can use curried functions. This type of function exploit the fact that functions are free to return functions as results.
	```haskell
	add’ :: Int -> (Int -> Int) 
	add’ x y = x+y 
	```
	Can be used in interesting way to partially define a function to be use later
	```haskell
	add5 = add' 5
	
	--gchci
	ghci> adds5 1
	6
	```
- Explain and use the notion of **type classes**
	Recall that a type is a collection of related values. Building upon this notion, a _class is a collection of types_ that support certain overloaded operations called methods.
	- `Eq`
	- `Ord`
	- `Show`
	- `Read`
	- `Num`
	- `Integral`
	- `Fractional`
- Explain the notions of **polymorphism** and **overloading** (parametric and ad hoc-polymorphism), the difference between them, and their relationship to type classes.
	- **polymorphism**: The meaning of the word polymorphic “of many forms” gives away the feature that the function with this property have. A polymorphic function is one in which is type contains one or more _type variables_. For example, the type of `length` is as follows: `length :: [a] -> Int`.
	- **overloading**: Ad hoc polymorphism or overloading is the property of a function to manage multiple types, possibly in different ways. The overloading of a function can be determined by is type that must contain a class constrain.  or example, the type of the addition operator `+` is as follows: `(+) :: Num a => a -> a -> a`.

### Theoretical Foundations
- Explain and use the **syntax and reduction semantics** of the pure λ-calculus
We consider a version of λ-calculus in which expressions have the abstract syntax given by the formation rules
$$e ::= x|\lambda x.e_1| e_1e_2$$
where $x$ is the variable, $\lambda x.e_1$ is the abstraction and $e_1e_2$ is the application.

**β-reduction** (the boss)
$$(\lambda x.\,e)\;e' \;\;\to\;\; e[x := e']$$
Notation: $[x := e']$ = “substitute all free occurrences of $x$ in $e$ with $e'$.

**α-conversion** (the helper)
$$\lambda x.\,e \;\;\to_\alpha\;\; \lambda y.\,e[x := y]$$
where $y$ is a fresh variable not occurring free in $e$. Used only to avoid **Name Clash** when performing substitution.

## Preparation Before Class

Before we meet on Tuesday:  
- Watch the podcast  
- Read the text (any order is fine)  
- Try to solve the following preparation problems (we will discuss them in class):  

### Problem 1
Write down Haskell definitions of `quango` and `tango` that have the following types.  
It is not important what the definitions do as long as they are type correct.

```haskell
quango :: a -> [a]
tango  :: Num p1 => (a, b) -> p2 -> p1
```

```haskell
quango :: a -> [a]
quango a = [a]

tango :: Num p1 => (a, b) -> p2 -> p1
tango (a,b) p2 = 44 
```

**Questions:**

* Are `quango` and `tango` polymorphic?
Yes, both function are polymorphic because they both have a type that is polymorphic hence the functions are also polymorphic. 

* If so, for each:
  * Does this involve **parametric polymorphism**?
The implementation of `quango` is pure parametric polymorphism because for every type that `a` might have the behavior is the same. The implementation of  `tango` is a mix, parametric polymorphism is int the input types `(a,b)` and `p2`.

  * Does this involve **overloading (ad hoc polymorphism)**?
The overloading is present only in the `tango` function and is only referred to the result type `p2` that is bound to the `Num` typeclass.

  * Or both? How?
The function `tango` makes us of both concepts. Parametric polymorphism for its inputs and overloading for his output.

* If not, why?
The function `quango` makes use only of parametric polymophism. There is no class constrain on the type of inputs nor on the type of the output.

---

### Problem 2

This problem is about the **λ-calculus** (as presented in the short note) and is **not related** to the content on types.

Find a terminating reduction sequence of the λ-expression:
$$
(λx.xy)(λz.(λu.uu))
$$
Use the reduction rules from the short note:
$$
(λx.xy)(λz.(λu.uu))
\to \text{beta reduction for x} \to (\lambda z.\lambda u.uu)y
\to \text{beta reduction for z} \to \lambda u.uu
$$

## In class problem session
1. What is the type of the function
```haskell
twice f x = f(f(x))
```

Explain your answer and how you found it.

my attempt
```haskell
twice :: f -> (f -> x)
```
> we have a curried function that takes a function and a whatever type

the correct result

```haskell
twice :: (t -> t) -> t -> t
```
on page 23 of the book we have 
$$
\frac{f :: A \to B \text{ and } e :: A}{f e :: B}
$$
`twice :: tf -> tx -> tr`
the function takes as is argument  `tf` (a function of a type), `tx`(a variable x) and they produce an output called `tr`.

Lets start developing the definition of `twice` we have the
inner application `f :: tx -> t1` that takes as an argument `tx` then the 
outer application `f :: t1 -> tr` takes a the result of the inner application and produces the end result `tr`.

The trick is in the fact that we need to apply the same function twice therefore the type of the result of the inner function needs to be the same as its input.
Now we can see that `t1` is just a result of the same type of `x` so `tx -> tr = tx -> tx`

`tf = tx -> tr` so `twice :: (tx -> tx) -> tx -> tx`


Then (and only then) check your answer using the Haskell interpreter. 

Is the function polymorphic? 
If it yes, tell us if this is parametric polymorphism or overloading (ad hoc polymorphism). If it is not, tell us why.

> the function uses parametric poly

What about the type of the function
```haskell
twicetwo (f,x) = f(f(x))
```

the type of the function is 
```haskell
twicetwo :: (t -> t, t) -> t
```

2. Here is a term in the λ-calculus:
$$(λx.xx)(λx.xx) \to_{\alpha} (\lambda z.zz)(\lambda x.xx) \to_{\beta} (λx.xx)(λx.xx)$$

Are the bound variables in the term distinct? 
No they are not.

If they are not, rename them such that they are.
first step is a alpha reduction

Once you have found the answer to this, then find a reduction step that the term can take. To do this, use the reduction rules of the note.
$$(λx.xx)(λx.xx) \equiv_{\alpha \text{ for the first term }} (\lambda z.zz)(\lambda x.xx)$$$$\to_{\beta \text{ for the variable } z} (yy)[y \to (\lambda x.xx)] \to (λx.xx)(λx.xx)$$

3. What is the type of the function
```haskell
dingo (x,y) = [x,y]
```

Explain your answer and how you found it. 
Given the fact that lists can have only one type the tuple variables need to have the same type to be put in the resulting list. 
```haskell
dingo :: (a,a) -> [a]
```

Then (and only then) check your answer using the Haskell interpreter. 

Is the function polymorphic? If it yes, tell us if this is parametric polymorphism
or overloading (ad hoc polymorphism). If it is not, tell us why.
> Here we have parametric polymorphism

4. Why are function types not allowed to be members of the type class Eq? Hint: Many of you have seen something called EQTM in courses you followed in a past life.

More problems to solve at your own pace
a. Here is a function.
```haskell
mango x y z = x ∗ y + z − 42
```
What is the type of `mango 14`? 
```haskell
mango 14 :: Num a => a -> a -> a
```
Explain your answer. 
The answer is this one because the `mango 14` definition is a partially defined function that can return only other two partially initialized function and the end result.

Then (and only then) check your answer using the Haskell interpreter.

b. Write down a definition of a function bingo that has the following type; it is not important what the definition does as long as it is type correct.
```
bingo :: a −> a
```

Is bingo polymorphic? If it yes, tell us if this is parametric polymorphism or overloading (ad hoc polymorphism). If it is not, tell us why.

c. Suppose you want to define a function `thesame` that takes a list of pairs `xs` and gives us the list of pairs whose first and second component are the same.
For example, we want the function application
```haskell
thesame [ ( 1 , 2 ) , ( 4 , 4 ) , ( 6 , 7 ) , ( 1 7 , 1 7 ) ]
```
to return the value
```haskell
[ ( 4 , 4 ) , ( 1 7 , 1 7 ) ]
```
What should the type of `thesame` be?

d. Here is a Haskell expression.
`[ (+) , ( ∗ ) , (+) , (−) ]`
What does it contain and what is the type of the expression? Find the answer without asking the Haskell interpreter. Explain why your answer is correct. Then (and only then!) ask the Haskell interpreter what the type is.
What can you say about the type of
`[ (+) , ( ∗ ) , (+) , (−) , (++) ]`

e. Suppose you want to define a function `map` that takes a function `f` and a list `xs` and returns the list
where `f` has been applied to every element in `xs`.
For example, suppose double is the function defined by
```
double n = 2 ∗ n
```
Then the function application
```
map double [ 1 , 2 , 3 , 4 ]
```
should return
`[ 2 , 4 , 6 , 8 ]`
What should the type of map be?

```haskell
map :: (a -> a) -> [a] -> [a]
```

f. Find a Haskell expression whose type is
```
(Ord a1, Eq a2) =>a2 −> a2 −> (a1, a1)−> a1
```

g. Here is the definition of a Haskell function.
``madras (f,x,y) = f (f x x) y``
Give a curried version of madras that has type (t −> t −> t)−> t −> t −> t
