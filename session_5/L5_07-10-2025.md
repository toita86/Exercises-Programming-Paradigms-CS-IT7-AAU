## The video podcast
[FP8 recursive functions](https://youtu.be/RB2Ca7uqsUg?si=Vd1CfgvGI6MzbPz7)
[FP11 - Thinking recursively](https://youtu.be/14corMR2sQ4?si=ZGVGd7IZvxs6VYdC)

## Tuesday 7 October 2025 – Recursion
The text is Chapter 6 of Programming in Haskell.
https://wiki.haskell.org/Monomorphism_restriction
## Learning goals for the session
>What is a recursive function? _Is a function defined in terms of itself_

- To understand the structure of a recursive function definition
- To be able to read and write recursive function definitions on lists
- To be able to read and write recursion definitions that make use of multiple recursion or mutual recursion
	**Simple recursion**
	
	A recursive function calls **itself** until it reaches a base case.
	
	Example:
	
	```haskell
	factorial :: Int -> Int
	factorial 0 = 1
	factorial n = n * factorial (n - 1)
	```
	
	Here, the function `factorial` calls **itself once** per iteration — this is *simple recursion*.
	
	---
	
	**Multiple recursion**
	
	A function is **multiple recursive** when it calls itself *more than once* within its definition.
	
	That means the recursive call happens in multiple branches or multiple times per call — often generating a tree of calls.
	
	Example: Fibonacci numbers
	
	```haskell
	fib :: Int -> Int
	fib 0 = 0
	fib 1 = 1
	fib n = fib (n - 1) + fib (n - 2)
	```
	
	Explanation:
	
	* For each `n`, the function calls itself **twice** (`fib (n-1)` and `fib (n-2)`).
	* That’s **multiple recursion** — a single function recursively depends on *multiple smaller subproblems*.
	
	Another example: quicksort
	
	```haskell
	qsort :: Ord a => [a] -> [a]
	qsort []     = []
	qsort (x:xs) = qsort [a | a <- xs, a <= x]
	             ++ [x] ++
	               qsort [a | a <- xs, a > x]
	```
	
	Here:
	
	* The function `qsort` calls itself **twice** — once for the smaller elements and once for the larger.
	* Again, **multiple recursion**.
	
	---
	
	**Mutual recursion**
	
	**Mutual recursion** happens when two (or more) functions call each other.
	
	Each one depends on the other’s result — forming a loop between definitions.
	
	Example: even and odd numbers
	
	```haskell
	even' :: Int -> Bool
	even' 0 = True
	even' n = odd' (n - 1)
	
	odd' :: Int -> Bool
	odd' 0 = False
	odd' n = even' (n - 1)
	```
	
	Explanation:
	
	* `even'` calls `odd'`
	* `odd'` calls `even'`
	* They recursively depend on each other → **mutual recursion**

- To be able to write recursive function definitions in a structured fashion
	1. Name the function.
	2. Write down its type.
	3. Enumerate the cases.
	4. Define the simple cases.
	5. List the "ingredients".
	6. Define the other cases.
	7. Think about the result.
## How you should prepare before we meet on Tuesday
Before we meet, watch the podcast and read the text. You can do this in any order you like. Also see if you can solve the following two small discussion problems. We will talk about them in class.

1. Define the function `replicate` using recursion – and use pattern matching in your solution. This function takes an integer `n` and and an element `x` and gives us a list with `n` elements where `x` has been repeated exactly `n` times. As an example, `replicate 3 5` should give us `[5,5,5]` . What should the type of replicate be?

```haskell
-- type inference says replicates :: (Eq n, Num n) => n -> a -> [a]
-- if we use this type allows also non integer numbers that cause 
-- an infinte loop. We need to constrain the type of `n`

replicates :: Int -> a -> [a]

replicates 0 _ = []
replicates n a = a : replicates (n-1) a

-- replicates n a = replicates (n - 1) a ++ [a]
```

2. Define the function `improve` using recursion – and use pattern matching in your solution. It takes a list `xs` and, if `xs` contains at least two elements, it gives us a list where every other element has been removed. As an example, improve `[1,2,3,4,5,6,7]` should give us `[1,3,5,7]` . What should the type of improve be?

```haskell
-- improve :: [a] -> [a]

improve [] = []

-- improve (x1:xs) = x1 : improve (drop 1 xs)

improve [x1] = [x1] 
improve (x1:_:xs) = x1 : improve xs 
```

## Lecture session
The function reverse appears in the Haskell prelude. It will reverse a list such that e.g. reverse `[1,2,3]` evaluates to `[3,2,1]` . Now it is your task to define your own version of this function, `rev`. First try to find out what the type of `rev` should be and follow the overall approach described in Section 6.6.
```haskell
-- reverse' :: [a] -> [a]

reverse' [] = []
reverse' (x:xs) = reverse' xs ++ [x]
```


A list `[a1, a2, . . . , an]` is descending if `a1 ≥ a2 ≥ . . . ≥ an`.
Write a function `descending` that will return `True` if a list is descending and `False` otherwise. As examples, descending `[6,5,5,1]` should return `True` and descending `[”plip”,”pli”,”ppp”]` should return False. What is its type?
```haskell
-- descending :: Ord a => [a] -> Bool
descending [_] = True
descending (x:y:xs) = (x >= y) && descending (y:xs)
```

The function `isolate` takes a list `l` and an element `x` and returns a pair of two new lists `(l1 , l2)`. The first list `l1` is a list that contains all elements in `l` that are not equal to `x`. The second list `l2` is a list that contains all occurrences of `x` in `l`.
• `isolate [4,5,4,6,7,4] 4` evaluates to `([5,6,7],[4,4,4])` .
• `isolate [’ g ’,’ a ’,’ k ’,’ a ’] ’a’` evaluates to `([’ g ’,’ k ’], [’ a ’,’ a ’])` 

Define `isolate` in Haskell without using `fst` , `snd`, `head` or `tail` . What should the type of isolate be? 
>Major hint: Place the recursive call in a let - or where-clause and use pattern matching to find the components in the result of that call.

```haskell
-- isolate :: Eq a => [a] -> a -> ([a],[a])

isolate [] _ = ([],[])
isolate (y:ys) x = if y == x then (l1, y:l2) else (y:l1,l2) where (l1,l2) = isolate ys x
-- l1 different from x 
-- l2 items are equal to x
```

The function `wrapup` is a function that takes a list and returns a list of lists. Each
list in this list contains the successive elements from the original list that are identical.
For instance, `wrapup [1,1,1,2,3,3,2]` should give us the list `[[1,1,1],[2],[3,3],[2]]` and `wrapup [True,True,False,False,False ,True]` should give us the list `[[ True,True ],[ False , False , False ],[ True]]`.
Define `wrapup` in Haskell using recursion but without using `fst` , `snd`, `head` or `tail`.

> ![hint]
> Recall the definition of the isolate function from before.

```haskell
-- wrapup :: [a] -> [[a]]

wrapup [] = []
wrapup [x] = [[x]]
wrapup (x : y : ys) = if x == y then (x : l) : l1 else [x] : l : l1
  where
    (l : l1) = wrapup (y : ys)
```
