## The video podcast
You can watch the podcast on YouTube via the course page on Moodle.
### FP6 Defining functions
```haskell
safetail :: [a] -> [a]

-- a)
safetail as = if null as then [] else tail as
-- safetail as = if null as then [] else (\(_:as) -> as) as

-- b)
safetail as  | null as = []
			| otherwise = (\(_:as) -> as) as

-- safetail as | null as = []
--             | otherwise = tail as

-- c)
safetail [] = []
safetail (_:xs) = xs
```

### FP7 List comprehensions
```haskell
-- First excercise
pyths :: Int -> [(Int,Int,Int)]

pyths n = [(x,y,z) | x <- [1..n], y <- [1..n], z <- [1..n], (x^2)+(y^2) == z^2]

-- Second exercise
factors :: Int -> [Int]

factors n = [x | x <- [1..n], n `mod` x == 0]

perfects :: Int -> [Int]

perfects n = [l | l <- [1..n], l == sum (init (factors l))]

-- perfects n = [l | l <- [1..n], l == sum [f | f <- factors l, f /= x]]
-- perfects n = [l | l <- [1..n], sum(factors(n)) - n == n]


-- Third exercise
scalProd :: [Int] -> [Int] -> Int

scalProd l1 l2 = sum [x * y | (x,y) <- zip l1 l2]
-- scalProd l1 l2 = sum [l1 !! i * l2 !! i | i <- [0..n-1]]
--   where n = length l1
```
## Tuesday 30 September 2025 – Defining functions; List comprehension
The text is Chapters 4 and 5 of Programming in Haskell.
### Learning goals for the session

### Conditional expressions

**Description**: In Haskell, `if ... then ... else ...` always requires an *else* branch.
**Example**:

```haskell
absVal :: Int -> Int
absVal x = if x < 0 then (-x) else x

-- absVal (-5) = 5
-- absVal 3    = 3
```

---

### Guards

**Description**: Guards provide a clean way to test multiple conditions in function definitions.
**Example**:

```haskell
sign :: Int -> String
sign x
  | x < 0     = "negative"
  | x == 0    = "zero"
  | otherwise = "positive"

-- sign (-3) = "negative"
-- sign 0    = "zero"
-- sign 5    = "positive"
```

---

### Pattern matching

**Description**: You can “destructure” values directly in function arguments. Works on lists, tuples, and algebraic data types.
**Example**:

```haskell
headOf :: [a] -> a
headOf (x:_) = x

-- headOf [1,2,3] = 1
```

---

### Anonymous functions (λ-expressions)

**Description**: Functions without a name, useful for short one-off definitions.
**Example**:

```haskell
squareList :: [Int] -> [Int]
squareList xs = map (\x -> x * x) xs

-- squareList [1,2,3] = [1,4,9]
```

---

### List comprehensions

**Description**: A concise way to build lists using generators and optional conditions.
**Basic Example**:

```haskell
pairs = [(x,y) | x <- [1..2], y <- [3,4]]
-- [(1,3),(1,4),(2,3),(2,4)]
```

---

### Guards in list comprehensions

**Description**: You can filter results with boolean conditions.
**Example**:

```haskell
evens = [x | x <- [1..10], even x]
-- [2,4,6,8,10]
```

---

### Dependent generators

**Description**: Later generators can depend on earlier ones, like nested `for` loops.
**Example**:

```haskell
triangles = [(a,b,c) | a <- [1..5], b <- [a..5], c <- [b..5]]
-- all non-decreasing triples
```

---

### Using comprehensions to define functions

**Description**: You can express many functions directly with comprehensions.
**Example**:

```haskell
pythagorean :: Int -> [(Int,Int,Int)]
pythagorean n = [(a,b,c) | a <- [1..n], b <- [a..n], c <- [b..n],
                           a^2 + b^2 == c^2]

-- pythagorean 10 = [(3,4,5),(6,8,10)]
```

---

### Building larger programs

**Description**: Combine conditionals, guards, pattern matching, and comprehensions to express logic concisely.
**Example**:

```haskell
classifyList :: [Int] -> String
classifyList xs
  | null xs          = "empty"
  | all even xs      = "all even"
  | any odd xs       = "some odd"
  | otherwise        = "mixed"

-- classifyList []       = "empty"
-- classifyList [2,4,6]  = "all even"
-- classifyList [1,2,3]  = "some odd"
```

### How you should prepare before we meet on Tuesday
Before we meet, watch the podcast and read the text. You can do this in any order you like.
Also see if you can solve the following two small preparation problems. We will talk about them in class.
1. Define, using pattern matching and _without using the length function_, a function `onlytwo` that tells us if a list has precisely two elements – in which case it must return True – or not, in which case it must return False. What is the type of `onlytwo`?
```haskell
onlytwo :: [a] -> Bool

onlytwo [] = False
onlytwo [a] = False
onlytwo (_:_:xs) = null xs

onlytwo_2 :: [a] -> Bool
onlytwo_2 [_,_] = True
```

2. The dot product of two pairs of numbers `(a, b)` and `(c, d)` is the number `a · c + b · d`. Define, using list comprehension, a function `alldots` that takes two lists of pairs of numbers and returns all the possible dot products of every pair from the first list and every pair from the second list. Find two good test case for testing your function definition and use them to test your code. What is the type of `alldots` ?
```haskell
alldots :: Num a => [(a,a)] -> [(a,a)] -> [a]

-- alldots lts1 lts2 = [(fst t1 * fst t2) + (snd t1 * snd t2) | t1 <- lts1, t2 <- lts2]
alldots lts1 lts2 = [(a * c) + (b * d) | (a,b) <- lts1, (c,d) <- lts2]

{- Test cases:

> a = [(1, 0), (0, 1)]
> b = [(0, 1), (1, 0)]
> alldots a b
> [0, 1, 1, 0]

> c = [(1, 0)]
> d = [(1, 0)]
> alldots c d
> [1]

-}
```

### Lecture session

`idhead`

```haskell
idhead :: Eq a => [(a,a)] -> Bool

idhead ((x,y):_) = x == y                  
idhead [] = False
```

`array` vs `list`
Arrays are a block of sequential memory that selects by an offset. Cant be easily defined recursively. Lookup O(1)

Lists are a single liked list to arrive to a element we need to pass between the elements and are not always sequential. They can be defined as a recursive datatype. Lookup O(n)

`pyth`

```haskell
pyt :: (Num c, Ord c, Enum c ) => c -> [(c,c,c)]

pyt n = [(a,b,c) | a <- [1..n], 
                   b <- [1..n], 
                   c <- [1..n], 
                   (a^2)+(b^2) == (c^2), 
                   a <= b && b < c]
```

`bighead`

```haskell
bighead :: Ord a => [a] -> Int

-- bighead (x:xs) = sum [1 | y <- xs, y > x]
bighead (x:xs) = length [y | y <- xs, y > x]
```

`plonk`

```haskell
plonk :: Num a => a -> a -> a -> a

-- plonk x y z = x + y + z
plonk = \a b c -> a+b+c
```

`isperfect`

```haskell
isperfect :: Integral a => a -> Bool

isperfect n = sum [x | x <- [1..n-1], n `mod` x == 0] == n
```

