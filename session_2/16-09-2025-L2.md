# Session 2 : First steps
## The video podcast
FP 4 - First Steps: https://www.youtube.com/watch?v=7hM4LrJVxDk

# First steps
The text is Chapters 1 and 2 of Programming in Haskell.

## Learning goals for the session
The learning goals are
- [x] To be able to explain the notion of a function in the functional programming paradigm in a precise way
    > [!IMPORTANT]
    > A _function_ is a mapping that takes one or more arguments and produces a single result, and is deﬁned using: 
    > - an equation that gives a name for the function, 
    > - a name for each of its arguments, 
    > - and a body that speciﬁes how the result can be calculated in terms of the arguments.

- [x] To understand the central points in the history of functional programming
- [x] To be able to install the Glasgow Haskell compiler and use it with a simple programming environment
- [x] To be able to write simple definitions in Haskell
- [x] To be able to edit, load and use Haskell programs
- [x] To understand and be able to apply simple aspects of Haskell syntax: Definitions, comments, the layout rule and where declarations in definitions.

How you should prepare before we meet on Tuesday
Before we meet, watch the podcast and read the text. You can do this in any order you like.
Also see if you can solve the following two small discussion problems using only the functions mentioned in Chapter 2 of the book. We will talk about them in class.

1. Load the program simple.hs available from the Moodle section about this session. 
Try to evaluate `laengde myList`.

```bash
ghci> laengde myList 
6
```

This function counts the elements in the provided list. The function uses the prepend operator `:` to detach the head of the list for each recursive call and counts all the elements until the base case is met, where the list is empty.

What do you think the result of `sumtree myBigOak` will be?
Try to explain why, Then check your answer by asking Haskell.

Its the sum of the nodes of a tree. 

```haskell
ghci> sumtree myBigOak 
44
```

The function `sumtree` sums all the nodes of a binary tree provided.

2. Define a function `second` that will, when given a list, return the second element of the list if it exists. As examples of what this function should do, we expect that
`second [ 1 , 4 , 5 , 6 ]`
will give us 4

`second [ "some" , " b i z a r r e " , "mango" ]`
will give us ”bizarre”. 

Show that your definition of second `works` for these examples of arguments. 
Then find two more examples of arguments and see what happens. Is your function a total function?

## What happens on Tuesday?

When we meet, some of you will present the solutions to the small discussion problems above.
We have found volunteers the week before.
You are also supposed to solve and discuss a collection of problems that can be found on
a separate page, available on the day of the session. You are supposed to participate in these
activities, not to sit and watch your fellow students engaging in the activites. Remember to have
your computer with you. You must have GHCi installed on it.

## Code provided
`simple.hs`
```haskell
-- This is the simple program from the slides from the introduction

laengde :: (Num p) => [a] -> p

laengde [] = 0
laengde (x:l) = 1 + (laengde l)

myList = [2,3,17,9,69,484000]

data BTree = BLeaf Int | BBranch Int BTree BTree deriving Show

-- sumtree :: BTree -> Int

sumtree (BLeaf x) = x
sumtree (BBranch x t1 t2) = let v1 = sumtree t1
                                v2 = sumtree t2
                            in x + v1 + v2


myBigOak = BBranch 14 (BLeaf 13) (BLeaf 17)

-- Quicksort

qsort :: (Ord a) => [a] -> [a]

qsort [] = []
qsort (x:xs) = small ++ [x] ++ big
                 where small = qsort [a | a <- xs, a <= x]
                       big   = qsort [a | a <- xs, a > x]
-- second
second :: [a] -> a
second [] = error "There no elements in the list"
second [x] = error "There is only one element"
second ns = ns !! 1
second_2 ns = head (reverse (take 2 ns))
second_3 (x:xs) = head xs
```

## Second session
Define a function midtover that will, when given a list xs of length n, return a pair of two lists (xs1,xs2) such that xs1 consists of the first ⌊ n/2 ⌋ elements from xs and such that xs2 consists of the remaining elements.

`midtover [ 1 , 4 , 5 , 6 ]`
should give us `([1,4],[5,6])`

and that
`midtover [ ” t h i s ” , ” i s ” , ” a c t u a l l y ” , ”a” , ”f a i r l y ” , ” l o n g ” , ” l i s t ” ]` will give us `([ ” t h i s ” , ” i s ” , ” a c t u a l l y ” ] , [ ”a” , ” f a i r l y ” , ” l o n g” , ” l i s t ” ])`

```haskell
-- midtover

midtover :: [a] -> ([a],[a])

midtover ns = (xs1, xs2)
  where
    xs1 = take (length ns `div` 2) ns
    xs2 = drop (length xs1) ns
```

In the text for today we see that nothing is done to check if the argument of a function on integers actually is an integer.
Is this something we should worry about?

> No, because the haskell language has an automatic type-system that does not need explicit checking.

Suppose you are asked to define functions iseven and isodd with
types
```haskell
iseven :: Integral a => a −> Bool
isodd :: Integral a => a −> Bool
```

such that `iseven` will take an integer and tell us if it is an even number and such that `isodd` will take an integer and tell us if it is an odd number. Somebody came up with the following
solution.

```haskell
iseven n = if n `div` 2 == 0 then True else False

isodd n = if iseven then False else True
```

Do these functions work as intended? Is this an example of
good coding style in Haskell?

Yes they work but is not a good example of coding style. The evaluation of the `if` is not needed, the statement evaluated by the if returns itself a boolean therefore can be used directly as the body of the function.

