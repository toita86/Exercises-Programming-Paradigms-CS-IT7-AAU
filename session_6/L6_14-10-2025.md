## The Video Podcast
[FP 10 - Higher-Order Functions](https://www.youtube.com/watch?v=4cqtYzG1Tfw)

**Topic:** Higher-order functions  
**Text:** Chapter 7 of *Programming in Haskell*

---

## Learning Goals for the Session

- To be able to explain precisely what a higher-order function is and what the type of a higher-order function is 
	>  A function is called _higher-order function_ if it takes a function as an argument **or** returns a function as a result. 
- To be able to explain precisely higher-order functions on lists including `map`, `filter`, `foldr` and `foldl`
	```haskell
	map (+1) [2,3,4,5]
	-- returns [3,4,5,6]
	
	filter even [1..10]
	--returns [2,4,6,8,10]
	
	-- foldr (function) (base_case) rappresents the primitive recursion pattern
	foldr (+) 0
	{-
		sum [] = 0
		sum (x:xs) = x + sum xs	
	-}
	
	all predicate xs = and [predicate x | x <- xs]
	all even [2,4,6]
	-- returns True
	
	-- at least one element satisifies a predicate
	any predicate xs = or [predicate x | x <- xs]
	any (== ' ') "Hello Word"
	--returns True
	
	takeWhile (/= ' ') "Hello Word"
	--returns "Hello"
	
	dropWhile (== ' ') "   abc"
	-- returns "abc"
	
	```
- To be able to explain and understand the recursive definitions of common higher-order functions on lists  
- To be able to use higher-order functions, including `map`, `filter`, `foldr` and `foldl`, for solving programming problems in Haskell  
- To be able to explain and use function composition in Haskell 
	```haskell
	(.) :: (b -> c) -> (a -> b) -> (a -> c)
	f . g = \x -> f (g x)  
	```

---

## How You Should Prepare Before We Meet on Tuesday

Before we meet, watch the podcast and read the text. You can do this in any order you like.  
Also see if you can solve the following two small discussion problems. We will talk about them in class.

---

### 1. The `positions` Function

Every letter in the lowercase English alphabet has a position.  
`"a"` has position 1, `"c"` has position 3 and `"h"` has position 8.

In Haskell, every string is a list of characters. So `String` is the same type as `[Char]`.  
We can define a function `positions` that, given a string of lowercase letters `str`, gives us the list of positions of the characters in `str`.

As an **Example:**
```haskell
> positions "abba"
> [1,2,2,1]
````

Use the higher-order functions in Chapter 7 to define `positions`.

It is useful to remember that the ordinal value of a character can be computed using the function `fromEnum` found in the Prelude.  
We have that `fromEnum 'a'` is 97 and that `fromEnum 'b'` is 98.

```haskell
positions :: String -> [Int]
positions = map (\x -> fromEnum x - 96)


positions' :: String -> [Int]
positions' = map ((\n -> n - 96) . fromEnum)

positions'' :: String -> [Int]
positions'' = foldr (\x xs -> (fromEnum x - 96) : xs) []
```

---

### 2. The `sumsq` Function

The function `sumsq` takes an integer `n` as its argument and returns the sum of the squares of the first `n` integers.  
So `sumsq n` returns the sum:

```
1² + 2² + ... + n²
```

**Examples:**

```haskell
sumsq 4
> 30
sumsq 9 
> 285
```

Use `foldr` to define `sumsq` — and do **not** use `map`.

```haskell
sumsq n = foldr (\x xs-> x^2+xs) 0 [1..n]

sumsq' n = foldr ((+).(^2)) 0 [1..n]
```
