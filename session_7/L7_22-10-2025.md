## The video podcast
[FP 12 - Declaring Types and Classes](https://www.youtube.com/watch?v=JDrMF0ondUU)

**Declaring types and type classes**  
The text is Chapter 8 of *Programming in Haskell*.

---

### Learning goals for the session

- To understand how `type`, `newtype` and `data` declarations and how they differ.

**Explanation:**  
These are ways to define types in Haskell, each with different use cases.

**Examples:**

-- `type`: just a synonym
```haskell
type Name = String
```
-- `newtype`: creates a distinct type with one constructor
```haskell
newtype UserId = UserId Int
```
-- `data`: creates a new type with one or more constructors
```haskell
data Shape = Circle Float | Rectangle Float Float
```

---

 - To be able to define functions over recursively defined data types using pattern matching.

**Explanation:**  
Recursive data types refer to themselves in their definition. Pattern matching allows you to define functions by matching the structure of these types.

**Example:**

```haskell
data Nat = Zero | Succ Nat
-- Function to convert Nat to Int
natToInt :: Nat -> Int
natToInt Zero = 0
natToInt (Succ n) = 1 + natToInt n
```

---

- To understand how recursively defined data types can be used to implement the formation rules of a language.

**Explanation:**  
Languages (like arithmetic expressions or programming languages) can be modeled using recursive types that reflect their grammar.

**Example:**

```haskell
data Expr = Val Int | Add Expr Expr
-- Evaluating an expression
eval :: Expr -> Int
eval (Val n) = n
eval (Add e1 e2) = eval e1 + eval e2
```

---

- To understand the notion of term constructors and how they are used.

**Explanation:**  
Term constructors are used to build values of a data type. They also allow pattern matching to deconstruct values.

**Example:**

```haskell
data Maybe a = Nothing | Just a
-- Using constructors
safeDiv :: Int -> Int -> Maybe Int
safeDiv _ 0 = Nothing
safeDiv x y = Just (x `div` y)
```

---

- To understand the principles of and be able to declare new instances of type classes.

**Explanation:**  
Type classes define behavior (like equality or printing). You can make your types behave like built-in ones by implementing instances.

**Example:**

```haskell
data Color = Red | Green | Blue
instance Show Color where  
	show Red = "Red"  
	show Green = "Green"  
	show Blue = "Blue"
```

---

- To understand how the above notions can be applied in the setting of a larger program.

**Explanation:**  
These concepts help build modular, type-safe, and maintainable programs by modeling data and behavior clearly.

**Example:**  
In a compiler project, you might use:

- `data` to define syntax trees,
- `type` for aliases like `Env = [(String, Int)]`,
- `newtype` for wrapping identifiers,
- type classes for pretty-printing or evaluation.

---

### Type Classes

A **type class** defines a set of functions that can be implemented by different types. It's like an interface in other languages.

Example:
```haskell
class Eq a where
  (==) :: a -> a -> Bool
```

This says: any type `a` that is an instance of `Eq` must define how `==` works for it.

---

### Instances

An **instance** makes a specific type a member of a type class by providing implementations for the class's functions.

Example:
```haskell
instance Eq Bool where
  True == True = True
  False == False = True
  _ == _ = False
```
=
This defines how equality works for `Bool`.

---

### Why Use Them?

Type classes let you write **generic functions** that work with any type that implements the required behavior.

Example:
```haskell
elem :: Eq a => a -> [a] -> Bool
```

This works for any type `a` that is an instance of `Eq`.

### How you should prepare before we meet on Tuesday

Before we meet, watch the podcast and read the text. You can do this in any order you like.  
Also see if you can solve the following two small discussion problems. We will talk about them in class.

---

### 1. Unary numerals consist of a finite sequence of I’s followed by a Z. 

The natural number n can be represented as n successive I’s and a Z, so e.g. 4 is represented in unary notation as IIIIZ.  
The natural number 0 is represented as Z.

Define a recursive datatype Unary for unary numerals and use your type definition to define a function `unary2int` of type:

```haskell
unary2int :: Unary -> Integer
```

that finds the natural number represented by a given number.  
As an example, unary IIIIZ should give us 4.

---

### 2. Use the declaration of the type Tree on page 97 to define a function `least` that finds the least element in a given binary tree.

What should the type of `least` be?

```haskell
least :: tree a -> a
```

